# jmake
# 
# A simple build system for Java
#
# Note: Run from project root!
# 
# This build system requires a lib/ and src/ directory at the top level. The 
# lib/ folder must contain all build time and run time dependencies. The goal
# is to make builds easier, to be able to share repo with all dependencies,
# to pin dependencies by having project specific dependencies, to make it
# easy to update dependencies if vulnerabilities are found, and to build without
# having Maven and all its dependencies installed, work with no network access,
# and with nothing but OpenJDK. 
# 
# Build a Java library:
#   cd project-dir
#   jmake
#
# Build a Java program:
#   cd project-dir
#   jmake package.MainClass
#
# Build a Java library or program for release:
#   jmake -r  or jmake -r package.MainClass
#
# Building a release requires that 1) the project directory is a git repo and 2)
# that it's status is clean.
#
# This creates a jar file from sources. It is not a runnable jar as those
# are difficult to update dependencies. 
#
# An executable script is automatically produced with the above command if a
# main class is provided to jmake.
#
# Don't separate the jar file from its lib/ folder. Instead, after unzipping
# this application, which you should have received with sources and libs,
# create an alias in your terminal like this (in ~/.bashrc):
#
# alias program-name="path/to/progam-name.sh"
#
# and then call it with just `program-name`.
# 
# This script copies itself into the top-level directory at the end so that 
# the build instructions can live with the code. It also means that builds can
# be modified per project. Just call build.sh instead of jmake. The copy doesn't
# happen until the end so it doesn't needlessly get copied and should produce 
# something that runs. The script directory is captured at the start as it can 
# be affected by later calls to cd.
#
# This script doesn't run tests (yet) or produce a build script for Windows.
#
# This script does not clean out prior builds. You must manually delete the
# generated bin/ folder to remove past build artifacts, old class files, etc.
#

# get the location of this script (See: https://stackoverflow.com/questions/59895/how-do-i-get-the-directory-where-a-bash-script-is-located-from-within-the-script)
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

# check that we are in the top level directory (a directory with src/ lib/)
[ ! -d "lib/" ] && echo "Directory not found: lib/. At top level of project?" && exit
[ ! -d "src/" ] && echo "Directory not found: src/. At top level of project?" && exit

# if release build (-r) check git status (from stackoverflow 155046)
if [ "$1" == "-r" ]; then
    if [ -z "$(git status --porcelain)" ]; then 
      echo "Git status is clean"
    else 
      echo "Uncommitted changes or untracked files"
      exit
    fi
fi

# get version (maybe we want to get the latest tag and complain if the latest is not tagged)
version="$(git rev-parse --short HEAD)"

# get project dir name
name=${PWD##*/}

# compile with java 8
echo "Compiling $name"
find -name *.java > file.list
javac --source 8 --target 8 -d bin/ -cp .:lib/* @file.list
rm file.list

# create jar file (not runnable) and move to top level
echo "Creating jar file"
cd bin/
jar cf $name-$version.jar .
mv *.jar ../
cd ..

# create the executable script if main class given
if [[ "$1" == "-r" && ! -z "$2" ]]
  then
    echo "Creating executable using main class: $2"
    echo "java -cp *:lib/* $2 \$*" > $name
    echo "java -cp *;lib/* $2.bat \$*" > "$name.bat"
    chmod +x $name
elif [ ! -z "$1" ]
  then
    echo "Creating executable using main class: $1"
    echo "java -cp *:lib/* $1 \$*" > $name
    echo "java -cp *;lib/* $1.bat \$*" > "$name.bat"
    chmod +x $name
else
    echo "Creating library jar (no main class given)"
fi

# update changelog (copy of git log)
echo "Updating changelog"
git log > changelog.txt

# copy this build script into the top level directory
cp $SCRIPT_DIR/build.sh .

